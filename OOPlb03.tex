\documentclass[12pt]{article} 
\usepackage[xetex, a4paper, left=2cm, right=2cm, top=2cm,bottom=2cm]{geometry}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}

%\tolerance=1000
%\emergencystretch=0.74cm 

\usepackage{polyglossia}
\setdefaultlanguage[spelling=modern]{russian}
\setotherlanguage{english} 
\defaultfontfeatures{Scale=MatchLowercase,Ligatures=TeX}  %% устанавливает поведение шрифтов по умолчанию  
\newfontfamily\cyrillicfont{Linux Libertine} 
\setromanfont[Mapping=tex-text]{Linux Libertine}
\setsansfont[Mapping=tex-text]{Linux Biolinum}
\setmonofont{DejaVu Sans Mono}
%\newfontfamily\cyrillicfont{Liberation Mono} 

%\usepackage{makecell}

%\usepackage{titlesec}
%\newcommand{\sectionbreak}{\clearpage}

%\renewcommand{\thesection}{\Alph{section}}
%\newcount\wd    \wd=\textwidth \multiply\wd by 8 \divide\wd by 17

\usepackage{minted}
\usemintedstyle{friendly}
\renewcommand\listingscaption{Код}
\newminted{bash}{frame=lines}
\newminted{c}{frame=leftline}

\usepackage[unicode, pdfborder={0 0 0 0}]{hyperref}

\author{Alaksiej Stankievič}
\title{лабораторная работа}

\begin{document}
\hypersetup{
pdftitle = {OOP 03 lab},
pdfauthor = {Alaksiej Stankievič},
pdfsubject = {лабораторная работа}
}% End of hypersetup

Во всех заданиях должны быть использованы динамические структуры, даже если существует реализации без их использования.

\section*{Задания}

\begin{enumerate}
 
 \item \emph{очень простая задача} Реализовать двоичное дерево поиска (это двоичное дерево, у которого левый потомок 
 меньше, а правый больше). Оно должно содержать операции поиска  элемента в дереве (есть элемент или нет элемента в 
 дереве), вставки элемента, удаление элемента, вывод всего дерева как отсортированной последовательности.
 \item \emph{очень простая задача} Реализовать структуру петля --- это односвязный список, конец которого может быть
 привязан  к произвольному элементу списка (в том числе где-то в середине). С помощью этой структуры промоделировать 
 десятичные дроби. Класс должен содержать метод, выводящий произвольное число цифр (вплоть до миллиона знаков после 
 запятой), содержать конструктор строящий данный класс на основании одного значения дробного типа либо двух значений 
 целого типа (числитель и знаменатель).
 \item \emph{очень простая задача} Реализовать стек на списках и с помощью его вычислить обратную польскую запись.
 \item \emph{очень простая задача} Реализовать очередь и на основе её смоделировать игру в <<пьяницу>>.
 \item \emph{очень простая задача} Реализовать \textbf{односвязный} список. Он должен содержать методы по вставке и 
 удалению одного элемента и подсписка, нахождения значения элемента на  заданной позиции,а также метод сортировки.
 \item \emph{очень простая задача} Реализовать \textbf{двухсвязный} список. Он должен содержать методы по вставке и 
 удалению одного элемента и подсписка, нахождения значения элемента на  заданной позиции,а также метод сортировки.
 
 \item Реализовать гибридный стек --- это стек, использующий односвязный список массивов равной длинны. Когда мы 
 находимся внутри массива, стек работает как стек на массивах, но если мы доходим до верхней границы, то добавляем 
 в список новый массив и переходим на него. Мы удаляем сегмент только тогда, когда он не используется и, более того,
 вершина находится в первой половине предыдущего сегмента. Реализовать все стандартные операции со стеком. 
 Написать программу, которая проверяет в текстовом файле  правильность расстановки трех видов скобок (круглых, 
 квадратных и фигурных).
 \item Реализовать гибридную очередь  --- это очередь, использующая односвязный список массивов равной длинны. Когда мы 
 находимся внутри массива, очередь работает как  очередь на массивах,  но если мы доходим до верхней границы, то 
 добавляем в список новый массив и переходим на него. Мы удаляем сегмент только тогда, когда он не используется и, 
 более того, вершина находится во второй половине следующего сегмента. Реализовать все стандартные операции с очередью. 
 Написать программу, которая читает из файла время прихода и время, необходимое на обслуживание клиента на кассе и 
 посчитать максимальную и среднюю длинну очереди. Время дискретно.
 \item Реализовать структуру пирамида (это двоичное дерево, у которого оба потомка меньше или равны предку). 
 Реализовать операции просмотра корня, удаления корня, добавления нового элемента. Написать программу, использующую 
 пирамиду как очередь с приоритетами, пользователь вводит число заданий, которые необходимо ввести, момент прихода
 задания и приоритет. Затем программа моделирует, в каком порядке будут выполняться задания. Считаем время дискретным.
 \item Реализвать кольцевую односвязную очередь. Методы добавления  и удаления элемента, перемещения опорных указателей 
 на один элемент вперед. С помощью такой очереди реализовать эмуляцию менеджера распределения процессорного времени 
 в операционной системе. Конкретно RR (round robin, карусельный) алгоритм\footnote{В многозадачных операционных системах
 выполняется несколько процессов одновременно с точки зрения человека. Но на самом деле в каждый момент времени 
 выполняется только один процесс, который очень быстро сменяется другим. Управление переключением между 
 процессами --- одна из основных задач операционной системы. Каждый процесс может выполняться одну или несколько единиц 
 (квантов) времени. Известно несколько различных алгоритмов управления процессами различной эффективности. 
 Под эффективностью понимается отношение полезного, (затраченного на реальную работу), ко всему времени, проведенному 
 в системе. 
 
 Алгоритм FIFO. Каждый процесс выполняется непрерывно все кванты времени, которые ему необходимы.
 Если приходит новый процесс, то он помещается в конец очереди и ждет, пока процессор освободится. 
 
 Алгоритм RR. Его параметром является количество квантов,
 предоставляемых одному процессу подряд (минимально один). Если процесс выполнялся отведенное непрерывное число квантов 
 времени и есть ожидающие процессы, то выполнение  переходит к следующему по кругу процессу. Поэтому этот алгоритм и 
 получил название карусельного. 
 
 В задачах, моделирующих управление процессами, необходимо будет прочитать
 (лучше из файла) набор пар чисел, первое число обозначает время прихода процесса в систему, а второе - число квантов 
 времени, необходимых процессу для выполнения всей своей  работы}\addtocounter{footnote}{-1}\addtocounter{Hfootnote}{-1}.
 Посчитать среднюю эффективность запущенных процессов.
 \item Реализовать очередь. Методы добавления  и удаления элемента. С помощью такой очереди реализовать эмуляцию 
 менеджера распределения процессорного времени в операционной системе. Конкретно FIFO (first input first output) 
 алгоритм\footnotemark. Посчитать среднюю эффективность запущенных процессов.
 \item Реализовать двухстороннюю очередь(deque). Методы добавления  и удаления элемента. С помощью такой очереди
 реализовать эмуляцию менеджера распределения процессорного времени в операционной системе с несколькими процессорами. 
 Процессор берёт задачи с головы дека, если процесс ветвится, то ветка помещается в голову дека того же процессора, 
 если у какого-либо процессора дек пустеет, то он <<ворует>> хвост в наиболее длинном деке другого процессора. Посчитать
 среднюю эффективность запущенных процессов. 
 \item Реализовать простой стек на списках, содержащий все стандартные операции по работе со стеком. С помощью него 
 реализовать калькулятор командной строки. Пользователь вводит математическое выражение, содержащее числа, 
 арифметические операции (включая возведение в степень и круглые скобочки), программа вычисляет результат данного
 выражения. Идея состоит в том, что с помощью одного стека мы традиционное математическое выражение превращаем 
 в обратную польскую  запись, а потом, с помощью второго стека, вычисляем эту польскую запись. 
 \item Реализовать структуру кольцо --- односвязный кольцевой список со специальными операциями --- возврат текущего 
 опорного элемента, передвижение опорной позиции на заданное  число шагов вперед, удаления опорного элемента, проверка 
на пустоту. Также для кольца определены операции пересечения, объединения и разности, как на множествах. Написать 
программу, использующую кольцо для генерации случайной последовательности неповторяющихся чисел.
 \item Хеш-таблица --- это структура данных, реализующая интерфейс ассоциативного массива, а именно, она 
позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и 
операцию удаления пары по ключу. Реализовать хеш-таблицу с цепочками. 
 \item Реализовать дерево разбора математических выражений и его вычисление. Написать программу которая составляет  
дерево разбора по введённому выражению, и выводит это дерево. 
 \item Написать программу построения направленного графа на основании, что одно действие нужно  производить раньше 
другого (вершина графа соответствует действию). Вывести линейный порядок выполнения действий (топологическая сортировка) 
или, что это невозможно сделать, если есть цикл в графе. 
 \item Написать программу построения графа путей между городами и рассчитать кратчайшие  расстояния между заданным 
городом и всеми остальными. В данном виде графа ребро лучше тоже представлять узлом особого вида.
 \item Написать программу построения графа трубопровода между городами и рассчитать  максимальную пропускную способность 
 между двумя заданными городами и всеми остальными. В данном виде графа ребро лучше тоже представлять узлом особого 
вида.
 \item Реализовать троичное дерево поиска и на основе его реализовать ассоциативный  массив с повторениями (multimap). 
Написать программу создающую краткий словарь.
 \item Реализовать двоичное дерево поиска, а на нем множество (set).
 \item Реализовать двоичное дерево поиска, а на нем ассоциативный массив (map).
 
 \item \emph{бонус} Реализовать любой список или граф символов, а на его основе реализовать текстовый редактор, с 
операциями вставки, замены и удаления текста в произвольной позиции. 
 \item \emph{бонус} Реализовать список с пропусками (skip list) --- вероятностная структура данных, основанная на 
нескольких параллельных отсортированных связных списках с эффективностью, сравнимой с двоичным деревом. Реализовать 
операции вставки поиска и удаления, а также визуализацию (качественная реализация оценивается отдельным бонусом).
 \item \emph{бонус} Реализовать самобалансирующееся AVL --- дерево. Реализовать стандартные операции в дереве поиска, 
визуализацию дерева (качественная реализация оценивается 
 отдельным бонусом).
 \item \emph{бонус} Реализовать самобалансирующееся B+ дерево. Реализовать стандартные операции в дереве поиска, 
визуализацию дерева (качественная реализация оценивается 
 отдельным бонусом).
 \item \emph{бонус} Реализовать самобалансирующееся дерево поиска --- дерамиду (по ключам является деревом поиска, а по 
приоритетам --- пирамидой). Если ключи приходят от пользователя, а 
 приоритеты генерируются случайно, то было показано, что дерамида в среднем является сбалансированной. Реализовать 
методы проверки наличия элемента, вставки элемента, 
 удаления элемента, оценки степени баланса, вывода в виде отсортированной последовательности и в древовидном виде с 
указанием ключа и приоритета. Оценить среднюю степень 
 балансировки.
 \item \emph{бонус} Реализовать самобалансирующееся RB-дерево (красно-черное дерево). Реализовать стандартные операции 
в дереве поиска, визуализацию дерева (качественная реализация оценивается 
 отдельным бонусом).
 \item \emph{бонус} Реализовать генеалогическое дерево в виде гетерогенного графа. Есть два типа узлов: люди и браки. У 
каждого человека есть указатель на родительский брак и массив указателей на собственные браки, дату рождения и смерти и 
полное имя. Брак содержит указатели на мужа и жену и массив указателей на детей. Реализовать методы добавления новых 
людей в дерево, заключения браков, методы, возвращающие список всех детей, всех супругов, родителей, всех предков, 
включая родителей до третьего колена\footnote {родители, бабушки, дедушки, прабабушки, прадедушки}. Метод визуализации 
всего дерева и сохранения в файл. Программа должна предоставлять интерактивное взаимодействие с существующим деревом.
 \item \emph{бонус} Система непересекающихся множеств --- структура данных, которая позволяет администрировать 
множество элементов, разбитое на непересекающиеся подмножества. При этом каждому подмножеству назначается его 
представитель --- элемент этого подмножества. Абстрактная структура данных определяется множеством трех операций {Union, 
Find, MakeSet}. Реализовать алгоритм Тарьяна для поиска LCA. Дано дерево и набор запросов вида: для данных вершин u и v 
вернуть их ближайшего общего предка (least common ancestor, LCA). Весь набор запросов известен заранее, т.е. задача 
сформулирована в режиме оффлайн.
 \item \emph{бонус} Префиксное дерево (также известно как бор) --- структура данных, позволяющая хранить ассоциативный 
массив, ключами которого являются строки. В отличие от бинарных деревьев, в листьях дерева не хранится ключ. Уже 
сохранённые символы алфавита в боре связаны с указателям на потомков данного узла. В корне находится пустая строка. С 
помощью бора обработать текст и посчитать сколько каждое слово в нём встречается, вывести список в алфавитном порядке.
 \item \emph{бонус} Реализовать конечный автомат --- абстрактную машину, которая может находится в заданном конечном 
наборе состояний, и переходить в них в зависимости от входа и текущего состояния. Конечный автомат удобно представлять в 
виде ориентированного графа, где вершины это состояния, а дуги указывают на другие вершины и содержат значения входа 
которые их активизируют. Все состояния автомата делятся на два вида: терминальные и остальные. Терминальным называется 
состояние в котором автомат может прекратить работу. Если на вход поступает символ не соответствующий ни одной дуге, то 
автомат <<ломается>>, если текущее состояние было терминальным, то вся считанная последовательность символов 
возвращается (записывается в массив строк), если было нетерминальным, то считанная последовательность символов 
игнорируется, после этого в любом случае считанная последовательность символов очищается, а автомат возвращается в 
начальное состояние. Написать программу, которая строит КА для распознавания десятичных, восьмеричных, шестнадцатеричных 
и дробных литералов языка С++ и извлекает их в четыре различных массива строк из файла на языке С++. 
\end{enumerate}

\end{document}