\documentclass[12pt, oneside]{article} 
\usepackage[xetex, a4paper, left=2cm, right=2cm, top=2cm,bottom=2cm]{geometry}
\usepackage[cm-default]{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\tolerance=1000
\emergencystretch=0.74cm 

\usepackage{polyglossia}
\setdefaultlanguage[spelling=modern]{russian}
\setotherlanguage{english} 
\defaultfontfeatures{Scale=MatchLowercase,Ligatures=TeX}  %% устанавливает поведение шрифтов по умолчанию  
\newfontfamily\cyrillicfont{Linux Libertine} 
\setromanfont[Mapping=tex-text]{Linux Libertine}
\setsansfont[Mapping=tex-text]{Linux Biolinum}
\setmonofont{DejaVu Sans Mono}
%\newfontfamily\cyrillicfont{Liberation Mono} 

\usepackage{makecell}

\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

\renewcommand{\thesection}{\Alph{section}}
\newcount\wd    \wd=\textwidth \multiply\wd by 8 \divide\wd by 17
\newcount\wdf   \wdf=\textwidth \multiply\wdf by 16 \divide\wdf by 17

\author{Aliaksiej Stankievič}
\title{Групповые задачи на обходы}
\begin{document}
\section{Калькулятор командной строки}

Программа выдаёт приглашение командной строки на ввод. Пользователь может ввести выражение в инфиксной (обычной) форме. Выражение может содержать следующие операции: $+$, $-$\footnote{только бинарный}, $\ast$, $/$, \textasciicircum\footnote{возведение в степень}  с естественными приоритетами, также могут употребляться круглые скобки, для изменения порядка выполнения операций (любой глубины вложенности) и числа, которые представлены десятичной записью (например, 12 или 3.14 (с точкой)). Все действия над числами интерпретируются так, как если бы они все были вещественными. Программа вычисляет значение выражение и выводит его, и снова выдаёт приглашение командной строки на ввод. Выход из программы осуществляется по ключевому слову (например, exit). Также у программы должен быть второй режим работы: после имени программы через пробел пишется вычисляемое выражение, программа его вычисляет и завершает работу. Программа должна выдать консольную помощь\footnote{как при выполнении с соответствующей опцией, так и при ключевом слове в собственной командной строке}, и выдавать сообщения об ошибках.

\subsection*{Идея}
Идея программы заключается в приведении инфиксной формы в постфиксную (обратная польская запись), это осуществляется с помощью стека. Затем постфиксная форма вычисляется, опять же с помощью стека. Постфиксную форму можно хранить (а можно и не хранить), для хранения оказывается удобной очередь.

Дальнейшие развитие может быть осуществлено добавлением математических функций (sin, cos, exp и т.д.) и унарного минуса, а также вводом специальной переменной ans, ответа предыдущего вычисления.

\subsection*{Ввод}

Однострочное инфиксное выражение. Не содержит переводов строк, но может содержать пробелы, которые игнорируются.

\subsection*{Вывод}

Результат выражения, либо сообщение об ошибке (синтаксическая или математическая).

\subsection*{Пример}

\begin{tabular}{| p{\number\wdf sp} |}
\hline
\textdollar calc \\
>2+2\\
4\\
>help\\
type in mathematical expression, for example:\\
(1.4-18)/5\textasciicircum2\\
>exit\\
\textdollar calc 2\textasciicircum(1/2)\\
1.41421356\\
\textdollar calc \textendash\textendash{}help\\
CLI calculator\\
\\
usage: calc [EXPRESSION]\\
EXPRESSION must be \\correct mathematical expression, for example:\\
(1.4-18)/5\textasciicircum2\\
\textdollar \\
\hline
\end{tabular}

\section{``Пьяница''}

Смоделировать игру в пьяницу по следующим правилам: изначальная колода перемешивается, делится на две равные части и отдаётся игрокам рубашкой вверх, два игрока кладут по одной карте с верха своей колоды (каждый раз очередь хода случайна), карты забирает тот игрок, чья карта имеет старший номинал, если номиналы равны, то оба игрока выкладывают по две карты рубашкой вверх (опять очередность ходов случайна) и третью карту лицом вверх, опять определяется победитель кона, если опять ничья запускается предыдущая процедура, если и после неё ничья, то победитель определяется с учётом старшинства мастей (червы, бубны, трефы и пики с наименьшим приоритетом). Проигрывает игрок, который не может положить карту.

\subsection*{Идея}

Реализуйте алгоритм качественной тасовки карт. Здесь кроме двух очевидных есть ещё одна очередь. Полезно стандартный функционал очереди дополнить функцией добавление одной очереди в конец другой.

\subsection*{Ввод}

Для удобства тестирования и моделирования в начале игры вводится число старших номиналов участвующих в игре. Например, если будет введено 5, то колода будет состоять из тузов, королей, дам, валетов и десяток всех мастей. Максимально возможное число номиналов 13, минимально --- 2.

\subsection*{Вывод}

Журнал записи ходов. Каждый кон отделяется от другого горизонтальной чертой. В начале кона слева и справа пишется число карт в колоде соответствующих игроков, затем ближе к центру выкладываются карты игроков. Карты обозначаются латинскими буквами и цифрами (для десятки можно использовать X), масти либо символами псевдографики, либо заглавными буквами английских названий\footnote{hearts, diamond, clubs, spades}, в конце кона стрелкой указать куда переходят карты. При желании можно использовать ncurses. В конце выведете выигравшего игрока. 

\subsection*{Пример}

\begin{tabular}{| p{\number\wdf sp} |}
\hline
\verb'enter number of nominals: 3'\\
\verb' 6          6'\\
\verb'       QS    '\\
\verb'    AC       '\\
\verb'    <----    '\\
\verb'_____________'\\
\verb' 7          5'\\
\verb'    AH       '\\
\verb'       KH    '\\
\verb'    <----    '\\
\verb'_____________'\\
\\
\hline
\\
\verb'13         19'\\
\verb'    7S       '\\
\verb'       7D    '\\
\verb'    ##       '\\
\verb'       ##    '\\
\verb'       ##    '\\
\verb'    ##       '\\
\verb'       XH    '\\
\verb'    XC       '\\
\verb'       ##    '\\
\verb'    ##       '\\
\verb'       ##    '\\
\verb'    ##       '\\
\verb'    QC       '\\
\verb'       QD    '\\
\verb'    ---->    '\\
\verb'_____________'\\
\\
\hline
\end{tabular}

\section{``Симплетрон'' с подпрограммами}

Расширить ``Симплетрон'' описанный у Дейтелов возможностью написания подпрограмм. Написать несколько программ на новом диалекте машинного языка в том числе и содержащую рекурсию. Симплетрон может быть модифицирован, а именно расширением памяти, вводом новых команд, а также вводом при необходимости вводом новых регистров.

\subsection*{Идея}

Создать стек вызова функций, в стек помещается адрес возврата, возможно также размещение аргументов функции и состояния регистра.

\subsection*{Ввод}

Программа в машинных кодах симплетрона.

\subsection*{Вывод}

Результат работы программы. Предусмотреть ошибки переполнения стека и обращения к пустому стеку.

\section{Лифт}

Промоделировать лифт. В файле задаётся число этажей (до 7) и информация о людях. Лифт одноместный. Люди на этажах выстраиваются в очередь. При выборе между вариантом с изменение направления движения и его сохранением предпочтение отдаётся последнему. Для простоты моделирования время считается дискретным. За одну единицу времени лифт перемещается на один этаж, за ту же единицу времени может на этаж прийти один человек. Гарантируется, что ни на каком этаже два человека не приходят одновременно. 

Желательно промоделировать различные жизненые ситуация, начало рабочего дня, перерыв на обед, лифт в офисе (много поездок между не первыми этажами), лифт в отеле (много поездок с первого на этажи и с этажей на первый). Неплохо ознакомится с пуасоновским потоком событий.

\subsection*{Ввод}

В первой строке файла число этажей $N$, $2\leq{}N\leq7$, во второй число людей. Далее в $P$, $1\leq{}P\leq1000$, строках приводится по три числа, этаж на который человек приходит, этаж на который он едет и момент прихода. В нулевой момент лифт находится на первом этаже.

\subsection*{Вывод}

Псевдографическая анимация лифта, пустой и полный лифт обозначаются разными символами. На этаже должно отображаться число (числом) стоящих в очереди в лифт. После окончания работы лифта необходимо вывести статистику: средняя длина очереди на этаже, максимальная длинна очереди на этаже (возможно среднее время ожидание лифта), среднее время простоя лифта, среднее число этажей одной поездки лифта. Если знаете как вычисляется, то и стандартное отклонение соответствующих величин. 

\subsection*{Пример}

\begin{tabular}{| p{\number\wdf sp} |}
\hline
input file\\
\hline
5\\
3\\
1 5 0\\
4 2 0\\
1 3 1\\
\hline
console output\\
\hline
\verb'   ___ '\\
\verb'   | | '\\
\verb' 1 | | '\\
\verb'   | | '\\
\verb'   |▣| '\\
\verb' 1 | | '\\
\hline
\end{tabular}

\section{``Жизнь'' с памятью}
Существует довольно известная ``игра'' ``жизнь'', которую придумал Джон Конвей. Её суть в том, что имеется клеточное поле, в котором клеточки могут находится в двух состояниях: ``живом'' и ``мёртвом''. Есть определённые правила, по которым клеточки рождаются, выживают и умирают. На основании такой простой модели можно сделать очень много интересного. Жизнь это один из возможных миров порождаемый клеточными автоматами. Все клеточные автоматы обычно конечные автоматы, но есть и более сложные ``машины'', например, автомат с магазинной памятью.

В автомате с магазинной памятью, помимо внутреннего состояния (для жизни это живой-мёртвый) и входа (для жизни это число соседей у клеточки), есть ещё стек которой также оказывает влияние на работу автомата. Вам предлагается заменить в ``жизни'' конечные автоматы, на автоматы с магазинной памятью.
\subsection*{Идея}
Вот правила ``жизни'': клеточка рождается, если у пустой клетки ровно 3 соседа, клеточка выживает если у неё 2 или 3 соседа, в остальных случаях она умирает.

Коэн отработал несколько вариантов параметров, добиваясь определённого оптимума (что поле не слишком обрастало или наооборот не усыхало), и хотя существует множество других клеточных миров, коэновский один из самых классических. Поэтому предлагаемые мною правила для расширенного варианта весьма условны, и требуют исследования и уточнения, но их может взять за отправную точку. Будет хранить в стеке число, которое означает смещение правил Коэна\footnote{например, если в стеке на вершине 3 то правила как в обычной жизни, если в на вершине 5, то клеточка рождается если у неё ровно 5 соседей и выживает если у неё 4 или 5 соседей.}. Если клеточка умирает, то в момент смерти она изменяет стек по следующим правилам: если число соседей в момент смерти лишь на 1 отличалось от значений выживания, то мы заталкиваем в стек новое число, которое больше на единицу текущей вершины, если умирали от одиночества и меньше на единицу, если --- от перенаселения; в остальных случаях смерти мы выталкиваем значение из стека. Есть несколько вариантов обработки стека: считать клеточку с пустым стеком коэновской или окаменевшей (она больше не может менять своего состояния)\footnote{тогда изначально по всему полю нужно запихать в стек начальное значение}.  

\subsection*{Ввод}

Желательно предоставить пользователю наиболее интерактивную возможность задать пользователю начальные условия на поле. У пользователя должна быть возможность запустить, приостановить и окончить моделирование.

\subsection*{Вывод}

Графическое или псевдографическое представления поля и его эволюции. Консоли достаточно, но можно ncurses или даже графику, если сумеете.

\subsection*{Пример}
\begin{tabular}{| p{\number\wdf sp} |}
\hline
Несколько итераций конвеевской жизни.\\
\hline
\verb'........................'\\
\verb'.##....##....#....#.....'\\
\verb'.##...#..#...#.....#....'\\
\verb'.......##....#...###....'\\
\verb'........................'\\
\verb'........................'\\
\hline
\verb'........................'\\
\verb'.##....##...............'\\
\verb'.##...#..#..###..#.#....'\\
\verb'.......##.........##....'\\
\verb'..................#.....'\\
\verb'........................'\\
\hline
\verb'........................'\\
\verb'.##....##....#..........'\\
\verb'.##...#..#...#.....#....'\\
\verb'.......##....#...#.#....'\\
\verb'..................##....'\\
\verb'........................'\\
\hline
\verb'........................'\\
\verb'.##....##...............'\\
\verb'.##...#..#..###...#.....'\\
\verb'.......##..........##...'\\
\verb'..................##....'\\
\verb'........................'\\
\hline
\verb'........................'\\
\verb'.##....##....#..........'\\
\verb'.##...#..#...#.....#....'\\
\verb'.......##....#......#...'\\
\verb'..................###...'\\
\verb'........................'\\
\hline
\end{tabular}

\end{document}